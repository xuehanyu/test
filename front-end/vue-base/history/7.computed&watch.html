<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="app">
        {{msg}}
    </div>
</body>
<script  src="../node_modules//vue/dist/vue.js"></script>
<script>
    let vm = new Vue({
        el:'#app',
        data(){
            return {
                msg: 'hello'
            }
        },
        methods: {
            fn(){
                console.log('fnfnfnfnfn')
            }
        },
        // watch的三种写法 函数、 对象、 字符串
        watch: {
            msg:  function(newValue, oldValue){
                console.log(newValue, oldValue)
            } // 只监控了msg 
            // [
            //     {  
            //         handler(oldValue, newValue){  // 当监控对象时，没有老值
            //             console.log('数据变了', oldValue, newValue)
            //         },
            //         deep: true  // 深度监控
            //     },
            //     {  // 只监控了msg
            //         handler(oldValue, newValue){  // 当监控对象时，没有老值
            //             console.log('数据变立马了', oldValue, newValue)
            //         },
            //         immediate: true  // 深度监控
            //     },
            //     'fn'  // 调用methods中的方法
            // ]
        },
    })

    setTimeout(()=>{
        vm.msg = 100
    },1000)


    // 计算属性 和 watch的区别（都是watcher）
    //  计算属性内部不会立马获取值，只有取值的时候才执行（有缓存的，如果依赖的数据不发生变化，则不更新结果）
    // watch默认会在内部先执行， 他要算出一个老值来，如果数据变化会执行回调函数

    //  算一个结果，不会使用methods， methods不具备缓存， 每一次页面重新渲染，都要执行methods
</script>
</html>

